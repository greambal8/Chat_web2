<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üîí –°–ï–ö–†–ï–¢–ù–´–ô –ß–ê–¢</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      padding: 12px;
    }
    #chat-container {
      width: 100%;
      max-width: 500px;
      background: #1e293b;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      overflow: hidden;
    }
    #messages {
      height: 340px;
      overflow-y: auto;
      padding: 12px;
      background: #0f172a;
    }
    .msg {
      margin-bottom: 10px;
      padding: 10px 12px;
      border-radius: 16px;
      max-width: 80%;
      word-wrap: break-word;
      font-size: 15px;
      line-height: 1.4;
      position: relative;
    }
    .my { background: #4f46e5; color: white; margin-left: auto; }
    .theirs { background: #334155; color: white; }
    .encrypted-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 18px;
      height: 18px;
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2z'/%3E%3C/svg%3E") no-repeat center;
      background-size: contain;
    }
    .system {
      text-align: center;
      padding: 8px;
      font-size: 13px;
      margin: 8px 0;
      border-radius: 8px;
    }
    .system.secure {
      background: rgba(74, 222, 128, 0.15);
      color: #4ade80;
      border: 1px solid #166534;
    }
    .system.warning {
      background: rgba(248, 113, 113, 0.15);
      color: #f87171;
      border: 1px solid #b91c1c;
    }
    .panel {
      padding: 12px;
      background: #1e293b;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input, button, label {
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #334155;
      font-size: 15px;
      background: #334155;
      color: #f1f5f9;
      min-width: 0;
    }
    #room-id, #key-input, #msg-input, #passphrase-input {
      flex: 1;
      min-width: 120px;
    }
    button {
      background: #4f46e5;
      cursor: pointer;
      white-space: nowrap;
    }
    button.danger { background: #dc2626; }
    #input-area, #file-create-area {
      display: none;
      padding: 12px;
      background: #0f172a;
      border-top: 1px solid #334155;
      text-align: center;
    }
    #file-input {
      display: none;
    }
    #file-label {
      display: inline-block;
      padding: 10px 16px;
      background: #334155;
      border-radius: 10px;
      cursor: pointer;
    }
    #kill-btn {
      margin: 0 12px 12px;
      padding: 12px;
      width: calc(100% - 24px);
    }
    #status {
      padding: 10px;
      text-align: center;
      font-size: 13px;
      color: #94a3b8;
      background: #0f172a;
    }
    #persist-label {
      display: flex;
      align-items: center;
      gap: 6px;
      background: transparent;
      border: none;
      color: #cbd5e1;
      font-size: 14px;
    }
    @media (max-width: 520px) {
      .panel { flex-direction: column; align-items: stretch; }
      #room-id, #key-input, #msg-input { width: 100%; }
    }
  </style>
</head>
<body>

<div id="chat-container">
  <div class="panel">
    <input type="text" id="room-id" placeholder="ID –∫–æ–º–Ω–∞—Ç—ã">
    <button id="connect-btn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
    <label id="persist-label">
      <input type="checkbox" id="persist-checkbox">
      –£–¥–µ—Ä–∂–∞–Ω–∏–µ
    </label>
  </div>

  <div class="panel" id="file-load-panel">
    <input type="file" id="file-input" accept=".by">
    <label for="file-input" id="file-label">–ó–∞–≥—Ä—É–∑–∏—Ç—å Christmas.by</label>
  </div>

  <div class="panel" id="key-panel" style="display:none;">
    <input type="text" id="key-input" placeholder="–ö–ª—é—á (64 hex)" maxlength="64">
    <button id="gen-key">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
    <button id="use-key">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å</button>
  </div>

  <div id="file-create-area">
    <button id="create-file-btn">–°–æ–∑–¥–∞—Ç—å Christmas.by</button>
  </div>

  <div id="input-area" style="display:none;">
    <input type="text" id="msg-input" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." autocomplete="off">
    <button id="send-btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
  </div>

  <div id="messages"></div>

  <div id="status">–ì–æ—Ç–æ–≤ –∫ –∑–∞—â–∏—â—ë–Ω–Ω–æ–º—É –æ–±—â–µ–Ω–∏—é</div>
  <button id="kill-btn" class="danger">KILL-CHAT</button>
</div>

<script>
// === –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï ===
const state = {
  currentTopic: null,
  aesKey: null,
  isConnected: false,
  isKeySet: false,
  messageHistory: [],
  currentKeyHex: '',
  isSecureConnection: false,
  sentMessageHashes: new Set(),
  clientId: 'client-' + Math.random().toString(36).substring(2, 10)
};

// === DOM –≠–õ–ï–ú–ï–ù–¢–´ ===
const elements = {
  roomInput: document.getElementById('room-id'),
  connectBtn: document.getElementById('connect-btn'),
  persistCheckbox: document.getElementById('persist-checkbox'),
  keyPanel: document.getElementById('key-panel'),
  keyInput: document.getElementById('key-input'),
  genKeyBtn: document.getElementById('gen-key'),
  useKeyBtn: document.getElementById('use-key'),
  fileInput: document.getElementById('file-input'),
  createFileBtn: document.getElementById('create-file-btn'),
  messagesDiv: document.getElementById('messages'),
  inputArea: document.getElementById('input-area'),
  msgInput: document.getElementById('msg-input'),
  sendBtn: document.getElementById('send-btn'),
  statusDiv: document.getElementById('status'),
  killBtn: document.getElementById('kill-btn')
};

// === MQTT –ö–õ–ò–ï–ù–¢ ===
const client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt');

// === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
const utils = {
  generateRoomId: () => 'r-' + Math.random().toString(36).substring(2, 10),
  
  setStatus: (msg) => { elements.statusDiv.textContent = msg; },
  
  addMessageToUI: (text, isOwn, isEncrypted = false) => {
    const div = document.createElement('div');
    div.className = `msg ${isOwn ? 'my' : 'theirs'}`;
    div.textContent = text;
    if (isEncrypted && isOwn) {
      const badge = document.createElement('div');
      badge.className = 'encrypted-badge';
      div.appendChild(badge);
    }
    elements.messagesDiv.appendChild(div);
    elements.messagesDiv.scrollTop = elements.messagesDiv.scrollHeight;
  },
  
  addSystemMsg: (text, type = 'normal') => {
    const div = document.createElement('div');
    div.className = `system ${type === 'secure' ? 'secure' : type === 'warning' ? 'warning' : ''}`;
    div.textContent = text;
    elements.messagesDiv.appendChild(div);
    elements.messagesDiv.scrollTop = elements.messagesDiv.scrollHeight;
  },
  
  getMessageHash: (text) => {
    return btoa(unescape(encodeURIComponent(text)));
  },
  
  saveSession: () => {
    if (!elements.persistCheckbox.checked || !state.isConnected) {
      sessionStorage.removeItem('secret-chat-session');
      return;
    }
    sessionStorage.setItem('secret-chat-session', JSON.stringify({
      room: elements.roomInput.value,
      messages: state.messageHistory.map(m => m.raw),
      timestamp: Date.now()
    }));
  },
  
  loadSession: () => {
    const saved = sessionStorage.getItem('secret-chat-session');
    if (!saved) return false;
    try {
      const s = JSON.parse(saved);
      if (Date.now() - s.timestamp > 86400000) return false;
      elements.roomInput.value = s.room;
      state.messageHistory = s.messages.map(m => ({ raw: m }));
      elements.persistCheckbox.checked = true;
      return true;
    } catch (e) {
      return false;
    }
  },
  
  loadAndDecryptHistory: async () => {
    elements.messagesDiv.innerHTML = '';
    for (const item of state.messageHistory) {
      if (item.raw.startsWith('ENC:') && state.isKeySet) {
        const plain = await cryptoUtils.decryptMsg(item.raw);
        utils.addMessageToUI(plain, false, true);
      } else if (item.raw.startsWith('SYS:JOIN:')) {
        const user = item.raw.split(':')[2];
        if (state.isSecureConnection) {
          utils.addSystemMsg(`üîí ${user} –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è (–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ)`, 'secure');
        } else {
          utils.addSystemMsg(`‚ö† ${user} –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è (–°–û–ï–î–ò–ù–ï–ù–ò–ï –ù–ï –ë–ï–ó–û–ü–ê–°–ù–û!)`, 'warning');
        }
      } else {
        utils.addMessageToUI('[üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ]', false);
      }
    }
  },
  
  resetUI: () => {
    elements.keyPanel.style.display = 'none';
    elements.createFileBtn.parentNode.style.display = 'none';
    elements.inputArea.style.display = 'none';
    elements.messagesDiv.innerHTML = '';
    elements.roomInput.disabled = false;
    elements.connectBtn.disabled = false;
  }
};

// === –ö–†–ò–ü–¢–û–ì–†–ê–§–ò–ß–ï–°–ö–ò–ï –§–£–ù–ö–¶–ò–ò ===
const cryptoUtils = {
  encryptMsg: async (plaintext) => {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoded = new TextEncoder().encode(plaintext);
    const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, state.aesKey, encoded);
    const combined = new Uint8Array(iv.length + cipher.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(cipher), iv.length);
    return 'ENC:' + btoa(String.fromCharCode.apply(null, combined));
  },
  
  decryptMsg: async (payload) => {
    if (!payload.startsWith('ENC:')) return '[–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç]';
    try {
      const b64 = payload.slice(4);
      const combined = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
      const iv = combined.slice(0, 12);
      const ct = combined.slice(12);
      const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, state.aesKey, ct);
      return new TextDecoder().decode(decrypted);
    } catch (e) {
      return '[‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]';
    }
  },
  
  deriveKeyFromPassphrase: async (passphrase, salt) => {
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      enc.encode(passphrase),
      'PBKDF2',
      false,
      ['deriveKey']
    );
    return crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  },
  
  encryptFileData: async (data, passphrase) => {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const aesKey = await cryptoUtils.deriveKeyFromPassphrase(passphrase, salt);
    const encoded = new TextEncoder().encode(data);
    const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, encoded);
    const result = new Uint8Array(16 + 12 + cipher.byteLength);
    result.set(salt, 0);
    result.set(iv, 16);
    result.set(new Uint8Array(cipher), 28);
    return result;
  },
  
  decryptFileData: async (buffer, passphrase) => {
    const salt = buffer.slice(0, 16);
    const iv = buffer.slice(16, 28);
    const ct = buffer.slice(28);
    const aesKey = await cryptoUtils.deriveKeyFromPassphrase(passphrase, salt);
    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
    return new TextDecoder().decode(decrypted);
  }
};

// === –§–ê–ô–õ–û–í–´–ï –û–ü–ï–†–ê–¶–ò–ò ===
const fileUtils = {
  createChristmasFile: async () => {
    if (!state.isConnected || !state.isKeySet) {
      alert('–°–Ω–∞—á–∞–ª–∞ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –∫–ª—é—á!');
      return;
    }

    const passphrase = prompt('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥–æ–≤—É—é —Ñ—Ä–∞–∑—É (4‚Äì24 —Å–∏–º–≤–æ–ª–∞):');
    if (!passphrase || passphrase.length < 4 || passphrase.length > 24) {
      alert('–§—Ä–∞–∑–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 4 –¥–æ 24 —Å–∏–º–≤–æ–ª–æ–≤');
      return;
    }

    const data = JSON.stringify({ 
      v: 1, 
      room: elements.roomInput.value, 
      key: state.currentKeyHex,
      clientId: state.clientId
    });
    try {
      const encrypted = await cryptoUtils.encryptFileData(data, passphrase);
      const blob = new Blob([encrypted], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Christmas.by';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      utils.addSystemMsg('‚úÖ –§–∞–π–ª Christmas.by —Å–æ–∑–¥–∞–Ω –∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'secure');
    } catch (e) {
      alert('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞');
    }
  },
  
  loadChristmasFile: async (file) => {
    const arrayBuffer = await file.arrayBuffer();
    const passphrase = prompt('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥–æ–≤—É—é —Ñ—Ä–∞–∑—É –¥–ª—è Christmas.by:');
    if (!passphrase) return;

    try {
      const decrypted = await cryptoUtils.decryptFileData(arrayBuffer, passphrase);
      const data = JSON.parse(decrypted);
      if (data.v !== 1 || !data.room || !/^[0-9a-f]{64}$/.test(data.key)) {
        throw new Error();
      }

      utils.addSystemMsg('‚úÖ –î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ Christmas.by', 'secure');
      state.isSecureConnection = true;
      utils.setStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Ñ–∞–π–ª...');
      elements.connectBtn.disabled = true;
      elements.roomInput.disabled = true;
      await chatUtils.connectToRoom(data.room);
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º clientId –∏–∑ —Ñ–∞–π–ª–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
      if (data.clientId) {
        state.secureClientId = data.clientId;
      }
      
      await chatUtils.activateKey(data.key);
    } catch (err) {
      alert('‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Ñ—Ä–∞–∑–∞ –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π —Ñ–∞–π–ª');
      utils.setStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏');
    }
  }
};

// === –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –ß–ê–¢–ê ===
const chatUtils = {
  connectToRoom: (room) => {
    return new Promise((resolve) => {
      state.currentTopic = `sc-${room}`;
      client.subscribe(state.currentTopic);
      state.isConnected = true;
      elements.roomInput.value = room;
      elements.roomInput.disabled = true;
      elements.connectBtn.disabled = true;
      elements.keyPanel.style.display = 'flex';
      utils.setStatus(`–ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫: ${room}`);
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
      setTimeout(() => {
        client.publish(state.currentTopic, `SYS:JOIN:${state.clientId}`, { qos: 1 });
      }, 500);
      
      resolve();
    });
  },
  
  activateKey: async (hex) => {
    const keyBuf = new Uint8Array(hex.match(/.{2}/g).map(b => parseInt(b, 16)));
    state.aesKey = await crypto.subtle.importKey('raw', keyBuf.buffer, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']);
    state.isKeySet = true;
    state.currentKeyHex = hex;

    elements.keyPanel.style.display = 'none';
    elements.createFileBtn.parentNode.style.display = 'block';
    elements.inputArea.style.display = 'flex';
    utils.setStatus('‚úÖ –ö–ª—é—á –∞–∫—Ç–∏–≤–µ–Ω. –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ.');
    utils.addSystemMsg('üîí –ó–∞—â–∏—â—ë–Ω–Ω—ã–π –∫–∞–Ω–∞–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.');
    await utils.loadAndDecryptHistory();
    utils.saveSession();
  },
  
  send: async () => {
    if (!state.isConnected || !state.isKeySet) return;
    const text = elements.msgInput.value.trim();
    if (!text) return;
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
    const messageId = Date.now() + '-' + Math.random().toString(36).substring(2, 8);
    const fullMessage = `${state.clientId}:${text}:${messageId}`;
    
    try {
      const encrypted = await cryptoUtils.encryptMsg(fullMessage);
      const messageHash = utils.getMessageHash(fullMessage);
      state.sentMessageHashes.add(messageHash);
      
      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å—Ä–∞–∑—É
      utils.addMessageToUI(text, true, true);
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ MQTT
      client.publish(state.currentTopic, encrypted, { qos: 1 });
      
      // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
      state.messageHistory.push({ raw: encrypted });
      
      elements.msgInput.value = '';
      utils.saveSession();
    } catch (e) {
      console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:', e);
      utils.addSystemMsg('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è', 'warning');
    }
  },
  
  resetChat: () => {
    if (state.currentTopic) {
      client.publish(state.currentTopic, 'SYS:WIPE', { qos: 1 });
    }
    
    // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
    state.aesKey = null;
    state.isConnected = false;
    state.isKeySet = false;
    state.isSecureConnection = false;
    state.messageHistory = [];
    state.sentMessageHashes.clear();
    state.secureClientId = null;
    
    // –°–±—Ä–æ—Å UI
    utils.resetUI();
    elements.persistCheckbox.checked = false;
    sessionStorage.removeItem('secret-chat-session');
    
    // –ù–æ–≤—ã–π ID –∫–æ–º–Ω–∞—Ç—ã
    elements.roomInput.value = utils.generateRoomId();
    utils.setStatus('–ß–∞—Ç —É–Ω–∏—á—Ç–æ–∂–µ–Ω. –ù–∞—á–∞—Ç–∞ –Ω–æ–≤–∞—è —Å–µ—Å—Å–∏—è.');
    
    // –û—á–∏—Å—Ç–∫–∞ MQTT
    if (state.currentTopic) {
      client.unsubscribe(state.currentTopic);
      state.currentTopic = null;
    }
  }
};

// === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
const init = () => {
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏
  if (!window.crypto || !window.crypto.subtle) {
    alert('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—é. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome, Firefox –∏–ª–∏ Edge.');
    return;
  }
  
  // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–µ—Å—Å–∏–∏
  if (!utils.loadSession()) {
    elements.roomInput.value = utils.generateRoomId();
  }
  
  utils.setStatus('–ì–æ—Ç–æ–≤ –∫ –∑–∞—â–∏—â—ë–Ω–Ω–æ–º—É –æ–±—â–µ–Ω–∏—é');
};

// === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===
elements.connectBtn.onclick = () => {
  const room = elements.roomInput.value.trim();
  if (!room) { 
    alert('–í–≤–µ–¥–∏—Ç–µ ID –∫–æ–º–Ω–∞—Ç—ã'); 
    return; 
  }
  chatUtils.connectToRoom(room);
  utils.saveSession();
};

elements.genKeyBtn.onclick = () => {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  elements.keyInput.value = Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
};

elements.useKeyBtn.onclick = () => {
  const hex = elements.keyInput.value.trim().toLowerCase();
  if (!/^[0-9a-f]{64}$/.test(hex)) {
    alert('–ö–ª—é—á ‚Äî 64 —Å–∏–º–≤–æ–ª–∞ hex (0-9, a-f)');
    return;
  }
  chatUtils.activateKey(hex);
};

elements.fileInput.onchange = (e) => {
  const file = e.target.files[0];
  if (file && file.name.endsWith('.by')) {
    fileUtils.loadChristmasFile(file);
  } else {
    alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .by');
  }
};

elements.createFileBtn.onclick = fileUtils.createChristmasFile;
elements.sendBtn.onclick = chatUtils.send;
elements.msgInput.onkeypress = (e) => { if (e.key === 'Enter') chatUtils.send(); };
elements.killBtn.onclick = chatUtils.resetChat;
elements.persistCheckbox.onchange = utils.saveSession;

// === –û–ë–†–ê–ë–û–¢–ö–ê MQTT –°–û–û–ë–©–ï–ù–ò–ô ===
client.on('message', async (topic, payload) => {
  if (topic !== state.currentTopic || !state.isConnected) return;
  
  const msg = payload.toString();
  const isSystemMessage = msg.startsWith('SYS:');
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
  if (isSystemMessage) {
    if (msg.startsWith('SYS:JOIN:')) {
      const clientId = msg.split(':')[2];
      const isSecure = state.isSecureConnection || (state.secureClientId && state.secureClientId === clientId);
      
      if (clientId !== state.clientId) {
        if (isSecure) {
          utils.addSystemMsg(`üîí –ö–æ—Ä—Ä–µ—Å–ø–æ–Ω–¥–µ–Ω—Ç –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è –±–µ–∑–æ–ø–∞—Å–Ω–æ`, 'secure');
        } else {
          utils.addSystemMsg(`‚ö† –í–ù–ò–ú–ê–ù–ò–ï: —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ù–ï –±–µ–∑–æ–ø–∞—Å–Ω–æ!`, 'warning');
        }
      }
    }
    return;
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç
  const messageHash = utils.getMessageHash(msg);
  if (state.sentMessageHashes.has(messageHash)) {
    state.sentMessageHashes.delete(messageHash);
    return;
  }
  
  // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
  state.messageHistory.push({ raw: msg });
  
  // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
  if (state.isKeySet) {
    try {
      const fullText = await cryptoUtils.decryptMsg(msg);
      const [senderId, text, messageId] = fullText.split(':');
      
      if (senderId && text) {
        const isOwn = senderId === state.clientId;
        utils.addMessageToUI(text, isOwn, true);
      }
    } catch (e) {
      utils.addMessageToUI('[‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]', false);
    }
  } else {
    utils.addMessageToUI('[üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ]', false);
  }
  
  utils.saveSession();
});

// === –ó–ê–ü–£–°–ö ===
window.onload = init;

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –≤–∫–ª–∞–¥–∫–∏
window.onbeforeunload = () => {
  if (state.isConnected && state.currentTopic) {
    client.publish(state.currentTopic, `SYS:LEAVE:${state.clientId}`, { qos: 1 });
  }
};
</script>
</body>
</html>
