<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üîí –°–ï–ö–†–ï–¢–ù–´–ô –ß–ê–¢</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      margin: 0;
      padding: 12px;
      color: #e2e8f0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }
    #chat-container {
      width: 100%;
      max-width: 500px;
      background: #1e293b;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      overflow: hidden;
    }
    #messages {
      height: 320px;
      overflow-y: auto;
      padding: 12px;
      background: #0f172a;
    }
    .msg {
      margin-bottom: 10px;
      padding: 10px 12px;
      border-radius: 16px;
      max-width: 80%;
      word-wrap: break-word;
      font-size: 15px;
      line-height: 1.4;
      position: relative;
    }
    .my { background: #4f46e5; color: white; margin-left: auto; }
    .theirs { background: #334155; color: white; }
    .encrypted-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 18px;
      height: 18px;
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2z'/%3E%3C/svg%3E") no-repeat center;
      background-size: contain;
    }
    .system {
      text-align: center;
      color: #94a3b8;
      font-size: 13px;
      margin: 8px 0;
    }
    .panel {
      padding: 12px;
      background: #1e293b;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input, button, label {
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #334155;
      font-size: 15px;
      background: #334155;
      color: #f1f5f9;
      min-width: 0;
    }
    #room-id, #key-input, #msg-input, #passphrase-input {
      flex: 1;
      min-width: 120px;
    }
    button {
      background: #4f46e5;
      cursor: pointer;
      white-space: nowrap;
    }
    button.danger { background: #dc2626; }
    #input-area, #file-create-area {
      display: none;
      padding: 12px;
      background: #0f172a;
      border-top: 1px solid #334155;
      text-align: center;
    }
    #file-input {
      display: none;
    }
    #file-label {
      display: inline-block;
      padding: 10px 16px;
      background: #334155;
      border-radius: 10px;
      cursor: pointer;
    }
    #passphrase-input {
      margin-top: 8px;
      font-family: monospace;
    }
    #kill-btn {
      margin: 0 12px 12px;
      padding: 12px;
      width: calc(100% - 24px);
    }
    #status {
      padding: 10px;
      text-align: center;
      font-size: 13px;
      color: #94a3b8;
      background: #0f172a;
    }
    #persist-label {
      display: flex;
      align-items: center;
      gap: 6px;
      background: transparent;
      border: none;
      color: #cbd5e1;
      font-size: 14px;
    }
    @media (max-width: 520px) {
      .panel { flex-direction: column; align-items: stretch; }
      #room-id, #key-input, #msg-input { width: 100%; }
    }
  </style>
</head>
<body>

<div id="chat-container">
  <div class="panel">
    <input type="text" id="room-id" placeholder="ID –∫–æ–º–Ω–∞—Ç—ã">
    <button id="connect-btn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
    <label id="persist-label">
      <input type="checkbox" id="persist-checkbox">
      –£–¥–µ—Ä–∂–∞–Ω–∏–µ
    </label>
  </div>

  <div class="panel" id="file-load-panel">
    <input type="file" id="file-input" accept=".by">
    <label for="file-input" id="file-label">–ó–∞–≥—Ä—É–∑–∏—Ç—å Christmas.by</label>
  </div>

  <div class="panel" id="key-panel" style="display:none;">
    <input type="text" id="key-input" placeholder="–ö–ª—é—á (64 hex)" maxlength="64">
    <button id="gen-key">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
    <button id="use-key">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å</button>
  </div>

  <div id="file-create-area">
    <button id="create-file-btn">–°–æ–∑–¥–∞—Ç—å Christmas.by</button>
  </div>

  <div id="input-area">
    <input type="text" id="msg-input" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." autocomplete="off">
    <button id="send-btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
  </div>

  <div id="messages"></div>

  <div id="status">–ì–æ—Ç–æ–≤ –∫ –∑–∞—â–∏—â—ë–Ω–Ω–æ–º—É –æ–±—â–µ–Ω–∏—é</div>
  <button id="kill-btn" class="danger">KILL-CHAT</button>
</div>

<script>
const roomInput = document.getElementById('room-id');
const connectBtn = document.getElementById('connect-btn');
const persistCheckbox = document.getElementById('persist-checkbox');
const keyPanel = document.getElementById('key-panel');
const keyInput = document.getElementById('key-input');
const genKeyBtn = document.getElementById('gen-key');
const useKeyBtn = document.getElementById('use-key');
const fileInput = document.getElementById('file-input');
const createFileBtn = document.getElementById('create-file-btn');
const messagesDiv = document.getElementById('messages');
const inputArea = document.getElementById('input-area');
const msgInput = document.getElementById('msg-input');
const sendBtn = document.getElementById('send-btn');
const statusDiv = document.getElementById('status');
const killBtn = document.getElementById('kill-btn');

let currentTopic = null;
let aesKey = null;
let isConnected = false;
let isKeySet = false;
let messageHistory = [];
let currentKeyHex = '';
let isSecureConnection = false;
let sentMessages = new Set();

// MQTT
const client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt');

// === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===
const generateRoomId = () => 'r-' + Math.random().toString(36).substring(2, 10);

const setStatus = (msg) => { statusDiv.textContent = msg; };

const addMessageToUI = (text, isOwn, isEncrypted = false) => {
  const div = document.createElement('div');
  div.className = `msg ${isOwn ? 'my' : 'theirs'}`;
  div.textContent = text;
  if (isEncrypted && isOwn) {
    const badge = document.createElement('div');
    badge.className = 'encrypted-badge';
    div.appendChild(badge);
  }
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
};

const addSystemMsg = (text, isSecure = false) => {
  const div = document.createElement('div');
  div.className = 'system';
  div.textContent = text;
  if (isSecure) {
    div.style.color = '#4ade80';
    div.textContent += ' (–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ)';
  }
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
};

const saveSession = () => {
  if (!persistCheckbox.checked || !isConnected) {
    sessionStorage.removeItem('secret-chat-session');
    return;
  }
  sessionStorage.setItem('secret-chat-session', JSON.stringify({
    room: roomInput.value,
    messages: messageHistory.map(m => m.raw),
    timestamp: Date.now()
  }));
};

const loadAndDecryptHistory = async () => {
  messagesDiv.innerHTML = '';
  for (const item of messageHistory) {
    if (item.raw.startsWith('ENC:') && isKeySet) {
      const plain = await decryptMsg(item.raw);
      addMessageToUI(plain, false, true);
    } else {
      addMessageToUI('[üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ]', false);
    }
  }
};

const encryptMsg = async (plaintext) => {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(plaintext);
  const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, encoded);
  const combined = new Uint8Array(iv.length + cipher.byteLength);
  combined.set(iv, 0);
  combined.set(new Uint8Array(cipher), iv.length);
  return 'ENC:' + btoa(String.fromCharCode.apply(null, combined));
};

const decryptMsg = async (payload) => {
  if (!payload.startsWith('ENC:')) return '[–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç]';
  try {
    const b64 = payload.slice(4);
    const combined = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    const iv = combined.slice(0, 12);
    const ct = combined.slice(12);
    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
    return new TextDecoder().decode(decrypted);
  } catch (e) {
    return '[‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]';
  }
};

// === –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ ===
const deriveKeyFromPassphrase = async (passphrase, salt) => {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    enc.encode(passphrase),
    'PBKDF2',
    false,
    ['deriveKey']
  );
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
};

const encryptFileData = async (data, passphrase) => {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const aesKey = await deriveKeyFromPassphrase(passphrase, salt);
  const encoded = new TextEncoder().encode(data);
  const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, encoded);
  const result = new Uint8Array(16 + 12 + cipher.byteLength);
  result.set(salt, 0);
  result.set(iv, 16);
  result.set(new Uint8Array(cipher), 28);
  return result;
};

const decryptFileData = async (buffer, passphrase) => {
  const salt = buffer.slice(0, 16);
  const iv = buffer.slice(16, 28);
  const ct = buffer.slice(28);
  const aesKey = await deriveKeyFromPassphrase(passphrase, salt);
  const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new TextDecoder().decode(decrypted);
};

const createChristmasFile = async () => {
  if (!isConnected || !isKeySet) {
    alert('–°–Ω–∞—á–∞–ª–∞ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –∫–ª—é—á!');
    return;
  }

  const passphrase = prompt('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥–æ–≤—É—é —Ñ—Ä–∞–∑—É (4‚Äì24 —Å–∏–º–≤–æ–ª–∞):');
  if (!passphrase || passphrase.length < 4 || passphrase.length > 24) {
    alert('–§—Ä–∞–∑–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 4 –¥–æ 24 —Å–∏–º–≤–æ–ª–æ–≤');
    return;
  }

  const data = JSON.stringify({ v: 1, room: roomInput.value, key: currentKeyHex });
  try {
    const encrypted = await encryptFileData(data, passphrase);
    const blob = new Blob([encrypted], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'Christmas.by';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    addSystemMsg('‚úÖ –§–∞–π–ª Christmas.by —Å–æ–∑–¥–∞–Ω –∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω!', true);
  } catch (e) {
    alert('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞');
  }
};

const loadChristmasFile = async (file) => {
  const arrayBuffer = await file.arrayBuffer();
  const passphrase = prompt('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥–æ–≤—É—é —Ñ—Ä–∞–∑—É –¥–ª—è Christmas.by:');
  if (!passphrase) return;

  try {
    const decrypted = await decryptFileData(arrayBuffer, passphrase);
    const data = JSON.parse(decrypted);
    if (data.v !== 1 || !data.room || !/^[0-9a-f]{64}$/.test(data.key)) {
      throw new Error();
    }

    addSystemMsg('‚úÖ –î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ Christmas.by', true);
    isSecureConnection = true;
    setStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Ñ–∞–π–ª...');
    connectBtn.disabled = true;
    roomInput.disabled = true;
    await connectToRoom(data.room);
    await activateKey(data.key);
  } catch (err) {
    alert('‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Ñ—Ä–∞–∑–∞ –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω—ã–π —Ñ–∞–π–ª');
    setStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏');
  }
};

// === –û—Å–Ω–æ–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è ===
const connectToRoom = (room) => {
  return new Promise((resolve) => {
    currentTopic = `sc-${room}`;
    client.subscribe(currentTopic);
    isConnected = true;
    roomInput.value = room;
    roomInput.disabled = true;
    connectBtn.disabled = true;
    keyPanel.style.display = 'flex';
    setStatus(`–ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫: ${room}`);
    resolve();
  });
};

const activateKey = async (hex) => {
  const keyBuf = new Uint8Array(hex.match(/.{2}/g).map(b => parseInt(b, 16)));
  aesKey = await crypto.subtle.importKey('raw', keyBuf.buffer, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']);
  isKeySet = true;
  currentKeyHex = hex;

  keyPanel.style.display = 'none';
  createFileBtn.parentNode.style.display = 'block';
  inputArea.style.display = 'flex';
  setStatus('‚úÖ –ö–ª—é—á –∞–∫—Ç–∏–≤–µ–Ω. –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ.');
  addSystemMsg('üîí –ó–∞—â–∏—â—ë–Ω–Ω—ã–π –∫–∞–Ω–∞–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.');
  await loadAndDecryptHistory();
  saveSession();
};

const send = async () => {
  if (!isConnected || !isKeySet) return;
  const text = msgInput.value.trim();
  if (!text) return;
  const encrypted = await encryptMsg(text);
  sentMessages.add(encrypted);
  client.publish(currentTopic, encrypted, { qos: 1 });
  msgInput.value = '';
  saveSession();
};

const resetChat = () => {
  if (currentTopic) client.publish(currentTopic, 'SYS:WIPE', { qos: 1 });
  aesKey = null;
  isConnected = false;
  isKeySet = false;
  isSecureConnection = false;
  messageHistory = [];
  sentMessages.clear();
  roomInput.disabled = false;
  connectBtn.disabled = false;
  keyPanel.style.display = 'none';
  createFileBtn.parentNode.style.display = 'none';
  inputArea.style.display = 'none';
  messagesDiv.innerHTML = '';
  persistCheckbox.checked = false;
  sessionStorage.removeItem('secret-chat-session');
  roomInput.value = generateRoomId();
  setStatus('–ß–∞—Ç —É–Ω–∏—á—Ç–æ–∂–µ–Ω. –ù–∞—á–∞—Ç–∞ –Ω–æ–≤–∞—è —Å–µ—Å—Å–∏—è.');
};

// === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ===
const init = () => {
  const saved = sessionStorage.getItem('secret-chat-session');
  if (saved) {
    try {
      const s = JSON.parse(saved);
      if (Date.now() - s.timestamp < 86400000) {
        roomInput.value = s.room;
        messageHistory = s.messages.map(m => ({ raw: m }));
        persistCheckbox.checked = true;
      }
    } catch (e) {}
  }
  if (!roomInput.value) {
    roomInput.value = generateRoomId();
  }
};

// === –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ===
connectBtn.onclick = () => {
  const room = roomInput.value.trim();
  if (!room) { alert('–í–≤–µ–¥–∏—Ç–µ ID –∫–æ–º–Ω–∞—Ç—ã'); return; }
  connectToRoom(room);
  saveSession();
};

genKeyBtn.onclick = () => {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  keyInput.value = Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
};

useKeyBtn.onclick = () => {
  const hex = keyInput.value.trim().toLowerCase();
  if (!/^[0-9a-f]{64}$/.test(hex)) {
    alert('–ö–ª—é—á ‚Äî 64 —Å–∏–º–≤–æ–ª–∞ hex (0-9, a-f)');
    return;
  }
  activateKey(hex);
};

fileInput.onchange = (e) => {
  const file = e.target.files[0];
  if (file && file.name.endsWith('.by')) {
    loadChristmasFile(file);
  } else {
    alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .by');
  }
};

createFileBtn.onclick = createChristmasFile;
sendBtn.onclick = send;
msgInput.onkeypress = (e) => { if (e.key === 'Enter') send(); };
killBtn.onclick = resetChat;
persistCheckbox.onchange = saveSession;

// === MQTT –æ–±—Ä–∞–±–æ—Ç–∫–∞ ===
client.on('message', async (topic, payload) => {
  if (topic !== currentTopic) return;
  const msg = payload.toString();
  const isLocal = sentMessages.has(msg);
  
  if (isLocal) {
    sentMessages.delete(msg);
    return; // –ù–µ –¥—É–±–ª–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
  }

  messageHistory.push({ raw: msg });
  
  if (isKeySet) {
    const plain = await decryptMsg(msg);
    addMessageToUI(plain, false, true);
  } else {
    addMessageToUI('[üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ]', false);
  }
  
  // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
  if (msg.startsWith('SYS:JOIN:')) {
    const user = msg.split(':')[2];
    if (isSecureConnection) {
      addSystemMsg(`üîí ${user} –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è (–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ)`, true);
    } else {
      addSystemMsg(`‚ö† ${user} –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è (–°–û–ï–î–ò–ù–ï–ù–ò–ï –ù–ï –ë–ï–ó–û–ü–ê–°–ù–û!)`, false);
    }
  }
  
  saveSession();
});

// –ó–∞–ø—É—Å–∫
window.onload = init;

// –ü—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª
client.on('connect', () => {
  if (isConnected) {
    client.publish(currentTopic, `SYS:JOIN:${Date.now()}`, { qos: 1 });
  }
});
</script>
</body>
</html>
