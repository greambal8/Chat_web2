<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üîí –°–ï–ö–†–ï–¢–ù–´–ô –ß–ê–¢</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      margin: 0;
      padding: 12px;
      color: #e2e8f0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }
    #chat-container {
      width: 100%;
      max-width: 500px;
      background: #1e293b;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      overflow: hidden;
    }
    #messages {
      height: 340px;
      overflow-y: auto;
      padding: 12px;
      background: #0f172a;
    }
    .msg {
      margin-bottom: 10px;
      padding: 10px 12px;
      border-radius: 16px;
      max-width: 80%;
      word-wrap: break-word;
      font-size: 15px;
      line-height: 1.4;
    }
    .my { background: #4f46e5; color: white; margin-left: auto; }
    .theirs { background: #334155; color: white; }
    .system {
      text-align: center;
      color: #94a3b8;
      font-size: 13px;
      margin: 8px 0;
    }
    .panel {
      padding: 12px;
      background: #1e293b;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input, button, label {
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #334155;
      font-size: 15px;
      background: #334155;
      color: #f1f5f9;
      min-width: 0;
    }
    #room-id, #key-input, #msg-input {
      flex: 1;
      min-width: 120px;
    }
    #share-link-obf {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background: #1e293b;
      color: #60a5fa;
      border: 1px dashed #4f46e5;
      border-radius: 8px;
      font-family: monospace;
      font-size: 13px;
    }
    button {
      background: #4f46e5;
      cursor: pointer;
      white-space: nowrap;
    }
    button.danger { background: #dc2626; }
    #input-area, #qr-area, #share-area {
      display: none;
      padding: 16px 12px;
      background: #0f172a;
      border-top: 1px solid #334155;
      text-align: center;
    }
    #qr-canvas {
      margin: 12px auto;
      width: 200px;
      height: 200px;
      background: white;
      padding: 4px;
      border-radius: 12px;
    }
    #kill-btn {
      margin: 0 12px 12px;
      padding: 12px;
      width: calc(100% - 24px);
    }
    #status {
      padding: 10px;
      text-align: center;
      font-size: 13px;
      color: #94a3b8;
      background: #0f172a;
    }
    #persist-label {
      display: flex;
      align-items: center;
      gap: 6px;
      background: transparent;
      border: none;
      color: #cbd5e1;
      font-size: 14px;
    }
    @media (max-width: 520px) {
      .panel { flex-direction: column; align-items: stretch; }
      #room-id, #key-input, #msg-input { width: 100%; }
    }
  </style>
</head>
<body>

<div id="chat-container">
  <div class="panel">
    <input type="text" id="room-id" placeholder="ID –∫–æ–º–Ω–∞—Ç—ã">
    <button id="connect-btn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
    <label id="persist-label">
      <input type="checkbox" id="persist-checkbox">
      –£–¥–µ—Ä–∂–∞–Ω–∏–µ
    </label>
  </div>

  <div class="panel" id="key-panel" style="display:none;">
    <input type="text" id="key-input" placeholder="–ö–ª—é—á (64 hex)" maxlength="64">
    <button id="gen-key">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
    <button id="use-key">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å</button>
  </div>

  <div id="qr-area">
    <div>–ü–æ–∫–∞–∂–∏—Ç–µ QR —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É:</div>
    <canvas id="qr-canvas" width="200" height="200"></canvas>
    <button id="close-qr">–°–∫—Ä—ã—Ç—å QR</button>
  </div>

  <div id="share-area">
    <div>–°—Å—ã–ª–∫–∞ (–æ–±—Ñ—É—Å—Ü–∏—Ä–æ–≤–∞–Ω–∞):</div>
    <input type="text" id="share-link-obf" readonly>
    <button id="copy-obf">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
  </div>

  <div id="messages"></div>

  <div id="input-area">
    <input type="text" id="msg-input" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." autocomplete="off">
    <button id="send-btn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
  </div>

  <div id="status">–ì–æ—Ç–æ–≤ –∫ –∑–∞—â–∏—â—ë–Ω–Ω–æ–º—É –æ–±—â–µ–Ω–∏—é</div>
  <button id="kill-btn" class="danger">KILL-CHAT</button>
</div>

<script>
// === –ü—Ä–æ—Å—Ç–æ–π QR-–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä (–Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∞–±–ª–∏—Ü—ã) ===
function drawQRCode(canvas, text) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞: —Ä–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç, –µ—Å–ª–∏ –Ω–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
  // –ù–æ –º—ã –≤—Å—Ç—Ä–æ–∏–º –º–∏–Ω–∏-–∫–æ–¥–∏—Ä–æ–≤—â–∏–∫ –¥–ª—è 40 —Å–∏–º–≤–æ–ª–æ–≤
  const size = 21; // QR Version 1
  const modules = Array(size).fill().map(() => Array(size).fill(false));

  // –ó–∞–≥–ª—É—à–∫–∏: —É–≥–ª–æ–≤—ã–µ –ø–æ–∑–∏—Ü–∏–∏
  function drawFinder(x, y) {
    for (let i = -1; i <= 7; i++) {
      for (let j = -1; j <= 7; j++) {
        if (x+i >= 0 && x+i < size && y+j >= 0 && y+j < size) {
          if ((i === -1 || i === 7 || j === -1 || j === 7) ||
              (i >= 0 && i <= 6 && j >= 0 && j <= 6 && (i%2 === 0 || j%2 === 0))) {
            modules[y+j][x+i] = true;
          }
        }
      }
    }
  }
  drawFinder(0, 0);
  drawFinder(size-7, 0);
  drawFinder(0, size-7);

  // –ü—Ä–æ—Å—Ç–æ –∑–∞–∫–æ–¥–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –∫–∞–∫ —á—ë—Ä–Ω—ã–µ/–±–µ–ª—ã–µ –ø–æ–ª–æ—Å—ã (–∏–º–∏—Ç–∞—Ü–∏—è)
  // –î–ª—è –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è ‚Äî –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ qrcode-generator, –Ω–æ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ ‚Äî —Ç–∞–∫:
  ctx.fillStyle = '#000';
  ctx.font = '10px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('–ö–õ–Æ–ß:', 100, 80);
  ctx.fillText(text.substring(0, 16), 100, 100);
  ctx.fillText(text.substring(16, 32), 100, 115);
  ctx.fillText(text.substring(32, 48), 100, 130);
  ctx.fillText(text.substring(48), 100, 145);
}

// –ù–æ —á—Ç–æ–±—ã –≤—Å—ë —Ä–∞–±–æ—Ç–∞–ª–æ ‚Äî –ø–æ–¥–∫–ª—é—á–∏–º qrcode-generator —á–µ—Ä–µ–∑ data URL
const qrScript = document.createElement('script');
qrScript.src = 'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js';
qrScript.onload = () => {
  window.qrLibLoaded = true;
  if (window.pendingQRText) {
    realDrawQR(window.pendingQRText);
  }
};
document.head.appendChild(qrScript);

function realDrawQR(text) {
  if (!window.qrLibLoaded) {
    window.pendingQRText = text;
    return;
  }
  const qr = qrcode(0, 'L');
  qr.addData(text);
  qr.make();
  const canvas = document.getElementById('qr-canvas');
  const ctx = canvas.getContext('2d');
  const size = qr.getModuleCount();
  const px = Math.floor(200 / size);
  ctx.clearRect(0, 0, 200, 200);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, 200, 200);
  ctx.fillStyle = '#000';
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      if (qr.isDark(r, c)) {
        ctx.fillRect(c * px, r * px, px, px);
      }
    }
  }
}

// === –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–¥ —á–∞—Ç–∞ ===
const client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt');
const roomInput = document.getElementById('room-id');
const connectBtn = document.getElementById('connect-btn');
const persistCheckbox = document.getElementById('persist-checkbox');
const keyPanel = document.getElementById('key-panel');
const keyInput = document.getElementById('key-input');
const genKeyBtn = document.getElementById('gen-key');
const useKeyBtn = document.getElementById('use-key');
const qrArea = document.getElementById('qr-area');
const shareArea = document.getElementById('share-area');
const shareLinkObf = document.getElementById('share-link-obf');
const copyObfBtn = document.getElementById('copy-obf');
const messagesDiv = document.getElementById('messages');
const inputArea = document.getElementById('input-area');
const msgInput = document.getElementById('msg-input');
const sendBtn = document.getElementById('send-btn');
const statusDiv = document.getElementById('status');
const killBtn = document.getElementById('kill-btn');
const closeQrBtn = document.getElementById('close-qr');

let currentTopic = null;
let aesKey = null;
let isConnected = false;
let isKeySet = false;
let currentKeyHex = '';
let messageHistory = [];

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
const generateRoomId = () => 'r-' + Math.random().toString(36).substring(2, 10);

const obfuscateData = (room, key) => {
  const data = `r=${room}|k=${key}`;
  let b64 = btoa(data);
  return b64.replace(/a/g, 'x').replace(/b/g, 'y').replace(/c/g, 'z').replace(/=/g, '');
};

const deobfuscateData = (obf) => {
  if (!obf) return null;
  let b64 = obf.replace(/x/g, 'a').replace(/y/g, 'b').replace(/z/g, 'c');
  while (b64.length % 4) b64 += '=';
  try {
    const decoded = atob(b64);
    const [rPart, kPart] = decoded.split('|');
    const room = rPart?.replace('r=', '');
    const key = kPart?.replace('k=', '');
    if (!room || !/^[0-9a-f]{64}$/.test(key)) return null;
    return { room, key: key.toLowerCase() };
  } catch (e) {
    return null;
  }
};

const setStatus = (msg) => { statusDiv.textContent = msg; };

const addMessageToUI = (text, isOwn) => {
  const div = document.createElement('div');
  div.className = `msg ${isOwn ? 'my' : 'theirs'}`;
  div.textContent = text;
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
};

const addSystemMsg = (text) => {
  const div = document.createElement('div');
  div.className = 'system';
  div.textContent = text;
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
};

const saveSession = () => {
  if (!persistCheckbox.checked) {
    sessionStorage.removeItem('secret-chat-session');
    return;
  }
  sessionStorage.setItem('secret-chat-session', JSON.stringify({
    room: roomInput.value,
    connected: isConnected,
    messages: messageHistory.map(m => m.raw),
    timestamp: Date.now()
  }));
};

const loadAndDecryptHistory = async () => {
  messagesDiv.innerHTML = '';
  for (const item of messageHistory) {
    if (item.raw.startsWith('ENC:') && isKeySet) {
      const plain = await decryptMsg(item.raw);
      addMessageToUI(plain, false);
    } else {
      addMessageToUI('[üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ]', false);
    }
  }
};

const encryptMsg = async (plaintext) => {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(plaintext);
  const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, encoded);
  const combined = new Uint8Array(iv.length + cipher.byteLength);
  combined.set(iv, 0);
  combined.set(new Uint8Array(cipher), iv.length);
  return 'ENC:' + btoa(String.fromCharCode.apply(null, combined));
};

const decryptMsg = async (payload) => {
  if (!payload.startsWith('ENC:')) return '[–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç]';
  try {
    const b64 = payload.slice(4);
    const combined = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    const iv = combined.slice(0, 12);
    const ct = combined.slice(12);
    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
    return new TextDecoder().decode(decrypted);
  } catch (e) {
    return '[‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]';
  }
};

const connectToRoom = async (room) => {
  currentTopic = `sc-${room}`;
  client.subscribe(currentTopic);
  isConnected = true;
  keyPanel.style.display = 'flex';
  setStatus(`–ü–æ–¥–∫–ª—é—á–µ–Ω–æ: ${room}`);
  connectBtn.disabled = true;
  roomInput.disabled = true;
  saveSession();
};

const activateKey = async (hex) => {
  const keyBuf = new Uint8Array(hex.match(/.{2}/g).map(b => parseInt(b, 16)));
  aesKey = await crypto.subtle.importKey('raw', keyBuf.buffer, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']);
  isKeySet = true;
  currentKeyHex = hex;

  keyPanel.style.display = 'none';
  inputArea.style.display = 'block';
  qrArea.style.display = 'block';
  shareArea.style.display = 'block';
  realDrawQR(`KEY:${hex}`);
  shareLinkObf.value = `${location.origin}${location.pathname}#${obfuscateData(roomInput.value, hex)}`;

  setStatus('‚úÖ –ö–ª—é—á –∞–∫—Ç–∏–≤–µ–Ω. –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ.');
  addSystemMsg('üîí –ó–∞—â–∏—â—ë–Ω–Ω—ã–π –∫–∞–Ω–∞–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.');
  await loadAndDecryptHistory();
  saveSession();
};

const send = async () => {
  if (!isConnected || !isKeySet) return;
  const text = msgInput.value.trim();
  if (!text) return;
  const encrypted = await encryptMsg(text);
  client.publish(currentTopic, encrypted, { qos: 1 });
  messageHistory.push({ raw: encrypted });
  addMessageToUI(text, true);
  msgInput.value = '';
  saveSession();
};

const resetChat = () => {
  if (currentTopic) client.publish(currentTopic, 'SYS:WIPE', { qos: 1 });
  aesKey = null;
  currentKeyHex = '';
  isConnected = false;
  isKeySet = false;
  messageHistory = [];
  roomInput.disabled = false;
  connectBtn.disabled = false;
  keyPanel.style.display = 'none';
  qrArea.style.display = 'none';
  shareArea.style.display = 'none';
  inputArea.style.display = 'none';
  messagesDiv.innerHTML = '';
  persistCheckbox.checked = false;
  sessionStorage.removeItem('secret-chat-session');
  roomInput.value = generateRoomId();
  setStatus('–ß–∞—Ç —É–Ω–∏—á—Ç–æ–∂–µ–Ω. –ù–∞—á–∞—Ç–∞ –Ω–æ–≤–∞—è —Å–µ—Å—Å–∏—è.');
};

const copyToClipboard = async (text) => {
  try {
    await navigator.clipboard.writeText(text);
    setStatus('‚úÖ –°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!');
  } catch (err) {
    const input = document.createElement('textarea');
    input.value = text;
    document.body.appendChild(input);
    input.select();
    document.execCommand('copy');
    document.body.removeChild(input);
    setStatus('‚úÖ –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ (—á–µ—Ä–µ–∑ fallback)');
  }
};

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
connectBtn.onclick = () => {
  const room = roomInput.value.trim();
  if (!room) { alert('–í–≤–µ–¥–∏—Ç–µ ID –∫–æ–º–Ω–∞—Ç—ã'); return; }
  connectToRoom(room);
};

genKeyBtn.onclick = () => {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  keyInput.value = Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
};

useKeyBtn.onclick = () => {
  const hex = keyInput.value.trim().toLowerCase();
  if (!/^[0-9a-f]{64}$/.test(hex)) {
    alert('–ö–ª—é—á ‚Äî 64 —Å–∏–º–≤–æ–ª–∞ hex (0-9, a-f)');
    return;
  }
  activateKey(hex);
};

closeQrBtn.onclick = () => qrArea.style.display = 'none';
copyObfBtn.onclick = () => copyToClipboard(shareLinkObf.value);
sendBtn.onclick = send;
msgInput.onkeypress = (e) => { if (e.key === 'Enter') send(); };
killBtn.onclick = resetChat;
persistCheckbox.onchange = saveSession;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
window.onload = async () => {
  const hash = location.hash.substring(1);
  const deobf = deobfuscateData(hash);
  if (deobf) {
    history.replaceState(null, null, ' ');
    roomInput.value = deobf.room;
    await connectToRoom(deobf.room);
    await activateKey(deobf.key);
    return;
  }

  const saved = sessionStorage.getItem('secret-chat-session');
  if (saved) {
    try {
      const s = JSON.parse(saved);
      if (Date.now() - s.timestamp < 86400000) {
        roomInput.value = s.room;
        messageHistory = s.messages.map(m => ({ raw: m }));
        isConnected = s.connected;
        if (isConnected) {
          await connectToRoom(s.room);
        }
        persistCheckbox.checked = true;
      }
    } catch (e) {}
  }

  if (!roomInput.value) roomInput.value = generateRoomId();
};

client.on('message', async (topic, payload) => {
  if (topic !== currentTopic) return;
  const msg = payload.toString();
  messageHistory.push({ raw: msg });
  if (isKeySet) {
    const plain = await decryptMsg(msg);
    addMessageToUI(plain, false);
  } else {
    addMessageToUI('[üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ]', false);
  }
  saveSession();
});
</script>
</body>
</html>
